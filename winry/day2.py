"""
爱德华老师学堂2：今天的内容是介绍字符串、数组、条件表达式，以及一个普普通通的算法题~
第二天可能内容多了点，不用一天看完也行hhh
慢也是快。
"""
# import this   # python这门语言的禅道，可以打开注释看看 :P 加上#号就是注释一行代码
print("============ let's get started ============")
# ============ let's get started ============

"""
字符串（虽然是很重要的类型，但是我觉得应该在数学的python题里占比比较小，可以不怎么看）：
作为基础类型的一种，为什么我单独拿出来说呢？因为字符串内置了相当多的方法
字符串可以单独拆成一个个字符，因此字符串也可以视为一个数组  _(:_」∠)_
简单说下内置的方法，与接下来的数组有些共性
因为方法实在太多了，只能侧重讲几个常用的，如果遇到新的方法可以@我 :P
"""
str1 = "hello"
# 可能较为重要的方法
print(str1[1])  # e，hello的第二个字符，下标为1
print(str1[1:3])  # el，下标1到3的字符串，不包含3
print("l" in str1)  # True，day1说过的成员运算符，意思是判断l是否 在 str1字符串内
print("l" not in str1)  # False，成员运算符，意思是判断l是否 不在 str1字符串内
print(str1.count("l"))  # 2，输出str1里l出现的次数
print(len(str1))    # 5，字符串长度

# 转换为字符串str()
print(str(123))  # 输出字符串 "123"
# 字符串格式化 %
# 占位符意义：%s 字符串占位符，%d 整数占位符，%f 浮点数占位符
# %f 是字符串的浮点数占位符，配合 % 运算符，使用3.9 取代%f部分
print("%s苦短，我学 %s %f" % ("人生", "python", 3.9))  # 人生苦短，我学 python 3.900000

"""
数组篇：
一切的数学基础，大部分各种层出不同的算法都以数组开始展开
如果硬要比喻，那就是盘古开天辟地的斧子，就是奥特曼的变身器（奇妙比喻 ╮(￣▽￣"")╭ ）
注：数组里面可以只包含一种元素，也可以包含多种不同类型元素
简单说下好了 ~~
"""

"""
基础用法，包括增加、删除、获取数组长度、截取数组的基本操作
"""
list2 = [17, 2, 83, 41, 50]     # 纯数字数组
list2.append(77)    # [17, 2, 83, 41, 50, 77]往数组右边加上元素77

list2 = [17, 2, 83, 41, 50]
list2.remove(50)    # [17, 2, 83, 41]删除数组的元素50

list2 = [17, 2, 83, 41, 50]
len(list2)      # 5，数组长度

list2 = [17, 2, 83, 41, 50]
list2[1:3]  # [2, 83] 获取包含下标为1到3的元素的数组，不包括3，即只要第二个和第三个元素，到第四个为止
list2[2:]   # [83, 41, 50]  获取包含下标从2到末尾的元素的数组，即从第三个元素到最后一个

"""
下面是不太用得上但可能有点用的，说一下
"""
list2 = [17, 2, 83, 41, 50]
list2.pop(1)    # 2，弹出下标为1的元素，即第二个元素，原数组变为[17, 83, 41, 50]

list2 = [17, 2, 83, 41, 50]
# 超简易实现冒泡算法的内置实现~~ 参考day1的冒泡算法
list2.sort()    # [2, 17, 41, 50, 83] 数组内置方法sort()，可以让数组排序，当方法内无参数时，数组将按升序排序

list2 = [17, 2, 83, 41, 50]
list2.sort(reverse=True)    # [83, 50, 41, 17, 2] 数组内置方法sort()，当方法内reverse=True时，数组将按降序排序

list2 = [17, 2, 83, 41, 50]
list2.reverse()     # [50, 41, 83, 2, 17] 数组反转

list1 = ['physics', 'chemistry', 1997, 2000, 3 + 5j]    # 拥有各种类型元素的数组

"""
元组篇：（忽略，就是不可变的数组而已）
基本就是数组的中括号换成了圆括号=。=
里面的元素不可改变
"""
tuple1 = (5, 4, 3)

"""
字典篇：键值对的经典代表，可以根据键获取对应的值
非常强大，键与值都可以为任意类型
"""
# 字典 类似java的map，kv
_dict = {"name": "Winry", "age": 18}
_dict["hobby"] = "unknown"  # 往字典里加入键值'hobby': 'unknown'
_dict["age"]    # 18 >.< 得到字典里键为age的值


"""
条件语句：
基本就是由if(条件) elif(条件) else组成
"""
# 整句话的意思就是，如果条件1成立，执行条件1的执行语句；如果条件2成立，执行条件2的执行语句；否则执行else的语句
if 1 == 1 and 2 == 2:   # 条件1
    print("1 = 1")
elif 1 == 2:    # 条件2
    print("impossible")
else:   # 兜底，以上条件都不成立时执行else语句
    pass    # 空语句，当你什么都不想做时但是语法不通过，可以使用pass语句 :P


print("============ finish ============")

"""
每日答疑时间 =。=
"""

"""
1/(1 * 2 * 3) + 1/(2 * 3 * 4) + ... + 1/(n * (n + 1) * (n + 2))
(1) 使用python表达
(2) 当n=100时，求和

一开始我看到题目时，第一反应就是高中时代的倒数第二道大题的数列求和=。=
然后马上开始想通项公式，想不出来（-。-），上网复习了下数列求和通项。。。
后来我忽然想到，我为啥要用高中的思维去做这个？
所以我觉得你后面遇到的题目，应该都是这种模拟算式的，直接模拟就完事 hhh
"""
def winry(num):
    sum = 0     # 获取和，定义的变量sum
    content = ""    # 没啥主要含义，只是想把表达式打印出来看看啦 >.<
    for i in range(1, num):     # 循环，从1开始，执行到num-1次为止，不包括num
        sum += 1/(i * (i + 1) * (i + 2))    # sum = sum + 1/(i * (i + 1) * (i + 2))，累加，模拟题目的公式
        # content += "1/(" + str(i) + " * " + str((i + 1)) + " * " + str((i + 2) + ") + "
        content += "1/(%d * %d * %d) + " % (i, (i + 1), (i + 2))    # 使用占位符，参考day2的30行，上一句注释是这句的丑陋写法 0.0
    else:
        # content = content[0:len(content) - 2] + "= " + str(sum)
        content = "%s = %s" % (content[0:len(content) - 2], str(sum))   # 使用占位符，参考day2的30行，上一句注释是这句的丑陋写法 0.0
        print("和为：%s" % str(sum))
        print("列表公式：%s" % content)
    return sum

winry(101)  # 因为要跑到n=100，所以给101，因为不包括101
